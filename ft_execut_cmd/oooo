/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   oooo                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/28 20:46:31 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/13 11:15:48 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"
void  execution_cmd(t_command 	*list , char **env)
{
	char *ptr ;
		int pid = fork();
		if(pid < 0)
			perror("fork");
		else if(pid == 0)
		{
			if (list->arg[0][0] == '/')
				ptr = list->arg[0];
			else
				ptr = path_command(list->arg[0]);
				
			if (!ptr)
			{
				printf("\033[1;33mcommand not found\n\033[0m");
				exit(127);
			}
			printf("\033[31m********* --> +++++++++++++++++++++++++++++ <-- **********\033[0m\n");
			if(execve(ptr, list->arg, env) == -1)
				perror("execve ");
				
			if (access(ptr, X_OK) == -1)
				exit(126);
		}
		// else
		// {
		// 	int status;
		// 	if(wait(&status) == -1)
		// 		perror("wait");
		// }
}
void  ft_exute( t_envarment *var , t_command *list , char **env)
{
	if (list == NULL)
		return ;

	if(ft_strcmp(list->content , "exit") == 0)
		exit(0);
		
	else if(ft_strcmp(list->content, "cd") == 0)
		ft_cd(list);
		
	else if (ft_strcmp(list->content, "pwd") == 0 )
		ft_pwd(list);
		
	else if(ft_strcmp(list->content, "export") == 0)
		ft_export(var , list );
		
	else if(ft_strcmp(list->content, "unset") == 0)
		ft_unset(var , list );

	else if(ft_strcmp(list->content, "env") == 0)
		ft_env(var );
		
	else if(ft_strcmp(list->content, "echo") == 0)
		ft_echo(list);		
		

	else
{

	printf("***********-----------------------+++++++++++++ pid1 = \n");
    int pipefd[2];
    pid_t pid1, pid2;

    // Create the pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Fork the first child process for `ls`
    pid1 = fork();
    if (pid1 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid1 == 0) {
        // In the first child process

        // Close the read end of the pipe
        close(pipefd[0]);

        // Redirect stdout to the write end of the pipe
        dup2(pipefd[1], STDOUT_FILENO);

        // Close the write end of the pipe (after duplication)
        close(pipefd[1]);

        // Execute `ls`
        // char *argv[] = {"/bin/ls", NULL};
		// execution_cmd(list , env);
		
        execve(list->arg[0], list->arg, env);
		list = list->next;
		printf("***********----------------//////-------+++++++++++++ pid1 = %s\n", list->content);

        // If execve fails
        perror("execve");
        exit(EXIT_FAILURE);
    }

    // Fork the second child process for `wc`
    pid2 = fork();
    if (pid2 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid2 == 0) {
        // In the second child process

        // Close the write end of the pipe
        close(pipefd[1]);

        // Redirect stdin to the read end of the pipe
        dup2(pipefd[0], STDIN_FILENO);

        // Close the read end of the pipe (after duplication)
        close(pipefd[0]);

        // Execute `wc`
        // char *argv[] = {"/usr/bin/wc", NULL};
        // execve(argv[0], argv, NULL);
		        execve(list->arg[1], list->arg, env);


        // If execve fails
        perror("execve");
        exit(EXIT_FAILURE);
    }

    // Parent process

    // Close both ends of the pipe
    close(pipefd[0]);
    close(pipefd[1]);

    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);

//     return 0;
// }

	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:19:45 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:19:46 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void ft_cd(t_command *list)
{
	char *path ;

			if (list->arg[1] == NULL)
			{
				path = getenv("HOME");
				if (chdir(path) == -1)
					perror("No such file or directory");
			}
			else
			{
				path = list->arg[1];
				if (chdir(path) == -1)
					perror("No such file or directory");
			}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/10 09:06:30 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/12 10:03:42 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	ft_echo(t_command *list)
{
	int i = 1;
	int j = 0;
	bool flag = true;
	if(list->arg[1])
	{
		while (list->arg[1][i])
		{
			if(list->arg[1][0] == '-' && list->arg[1][i] == 'n')
				flag = true;
			else
			{
				flag = false;
				break;
			}
			i++;
		}	
	}
	if(flag == true)
	{
		ft_echo_flag(list);
		return ;
	}
	i = 1;	
	while(list->arg[i])
	{
		j =0;
		while (list->arg[i][j])
		{
			write(1, &list->arg[i][j], 1);
			j++;
		}
		write(1, " ", 2);
		i++;
	}
	write(1, "\n", 1);
}

void 	ft_echo_flag(t_command  *list)
{
	int i = 2;
	int j;
	while(list->arg[i + 1] && list->arg != NULL)
	{
		j = 0;
		while(list->arg[i][j])
		{
			write(1, &list->arg[i][j], 1);
			j++;
		}
		write(1, " ", 1);
		i++;
	}
	j = 0;
	while(list->arg[i][j] && list->arg != NULL)
	{
		write(1, &list->arg[i][j], 1);
		j++;
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:19:49 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:19:50 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void 	ft_env( t_envarment *var)
{
	t_envarment *ptr;
	ptr = var;
	while (ptr)
	{
		printf("%s <<<>> %s \n", ptr->var, ptr->data);
		ptr=ptr->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:19:52 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:19:53 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h" 

// t_envarment *ft_stock_envarment(char **env)
// {
// 	t_envarment *var=NULL;
// 	char **list;
// 	int i =0;
// 	while (env[i])
// 	{
// 		list = ft_split(env[i], '=');
// 		t_envarment *elem = new_node(list[0],list[1]);
// 		add_back_node(&var , elem);
// 		free(list);
// 		i++;
// 	}
// 	return var;
// }

int 	test_exist(t_envarment *var , char **list)
{
	t_envarment *ptr;
	ptr = var;
	while (ptr)
	{
		if(ft_strcmp(ptr->var, list[0]) == 0 && ft_strcmp(ptr->data,list[1]) == 0)
			return 0;

		else if(ft_strcmp(ptr->var,list[0]) == 0 && ft_strcmp(ptr->data,list[1]) != 0 )
		{
			ptr->data=list[1];
			return 0;
		}
		ptr = ptr->next;
	}
	return 1;
}
void free_args(char **args)
{
    if (args)
    {
        free(args[0]);
        free(args[1]);
        free(args);
    }
}
char	**split_line(char *ptr)
{
	int i;
	int count=0;;

	char **arg = (char **)malloc(sizeof(char *) * 2);
	if(arg == NULL)
		return NULL;
	i=0;
	while (ptr[i])
	{
		if (ptr[i] == '=')
			count++;
		i++;
	}
	if(count == 0)
	{ 
		arg[0] = ft_strdup(ptr);
		arg[1] = ft_strdup("");
	}
	else
	{
		arg[0]=ft_substr(ptr, 0, ft_strchr(ptr, '=') - ptr);
		arg[1]=ft_strdup(ft_strchr(ptr, '=')+1);
		if (arg[1][0] == '\0')
			arg[1] = ft_strdup("\"\"");
	}
	if (arg[0] == NULL || arg[1] == NULL)
		return( free_args(arg), NULL); 
	return arg;
}
void print_export(t_envarment *var, t_command *str)
{
	if(str->arg[1] == NULL)
	{
		while (var)
		{
			printf("declare -x %s=\"%s\"\n", (char *)var->var, (char *)var->data);
			var = var->next;
		}
	}
}

void 	ft_export( t_envarment *var ,t_command *str )
{
	char **list;
	int i=1;
	while(str->arg[i] != NULL)
	{
		list = split_line(str->arg[i]);
		if( test_exist(var, list) == 0)
		{
			i++;
			break;
		}
		else
		{
			t_envarment *elem = new_node(list[0],list[1]);
			add_back_node(&var , elem);
		}
		free(list);
		i++;
	}
	print_export(var, str);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pwd.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:20:01 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:20:02 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void ft_pwd(t_command *list)
{
	(void)list;
	char *path ;
			path = getcwd(NULL, 0);
			if(path == NULL)
				return ;
			printf("%s\n", path);	
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:06:34 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:19:25 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"


void 	ft_unset(t_envarment *var , t_command *list)
{
	t_envarment *env, *env_1;
	env = var;
	env_1 = var;
	int i=1;

	while (list->arg[i])
	{
			while (env_1)
			{
				if (ft_strcmp(env_1->var , list->arg[i]) == 0)
				{
					env->next = env_1->next;
					free(env_1);
				}
				env = env_1;
				env_1 = env_1->next;
			}
		env = var;
		env_1 = var;
		i++;
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   functions.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:20:09 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/12 12:40:15 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"


int ft_strcmp(char *s1, char *s2)
{
	if(!s1 || !s2)
		return -1;
	int i =0;
	while((s1[i] == s2[i]) && s1[i] && s2[i])
	{
		i++;
	}
	return (s1[i] - s2[i]);

}
char **create_argv(t_splitor *elem) 
{
	int count = 0;
	char **argv;
	t_splitor *tmp ;

	tmp = elem;
	while (tmp)
	{
		count++;
		tmp = tmp->next;
	}
	argv = (char **)malloc(sizeof(char *) * (count + 1));
	if (!argv)
		return (NULL);
	tmp = elem;
	int i = 0;
	while (tmp)
	{
		argv[i] = ft_strdup(tmp->in);
		if(!argv[i])
		{
			int j = 0;
			while (j < i)
			{
				free(argv[j]);
				j++;
			}
		}
		i++;
		tmp = tmp->next;
	}
	argv[count] = NULL;
	return argv;
}


char 	*path_command(char *ptr)
{
	char *path;
	char **list;
	int i=0;
	int a;
	char *tmp ;
	char *tmp2;

	path  = getenv("PATH");
	if(!path)
		perror("Error: PATH not found\n");
	
	list = ft_split(path, ':');
	while (list[i])
	{
		if(ptr[0] == '/')
			tmp2 = ptr;
		else
		{
			tmp = ft_strjoin(list[i], "/");
			tmp2 = ft_strjoin(tmp, ptr);
		}
		a = access(tmp2, F_OK) ;
		if (a == 0)
		{
			free(ptr);
			return tmp2;
		}
		i++;
	}
	free(ptr);
	ptr =NULL;
return ptr;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utilis_env.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/09 19:20:16 by bouhammo          #+#    #+#             */
/*   Updated: 2024/08/09 19:20:17 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

t_envarment  *new_node(void *var, void *data)
{
        t_envarment  *elem;

        elem = (t_envarment *)malloc(sizeof(t_envarment));
        if (!elem)
                return (NULL);
        elem->var = var;
		elem->data = data;
        elem->next = NULL;
        return (elem);
}


void    add_back_node(t_envarment **lst, t_envarment *new)
{
        t_envarment  *p;

        p = *lst;
        if (!lst || !new)
                return ;
        if (!(*lst))
        {
                *lst = new;
                return ;
        }
            while (p->next)
    {
       p=p->next;
    }
    p->next =new;
}

SRC= minishell.c \
	lexer_utils.c \
	lexer.c \
	ft_handle_synx.c \
	ft_nodes_env.c \
	ft_free.c \
	ft_parsser.c\
	parsser_utils.c \
	ft_direction.c \
	ft_execut_cmd/execute.c ft_execut_cmd/functions.c ft_execut_cmd/ft_cd.c   ft_execut_cmd/ft_pwd.c \
	ft_execut_cmd/ft_export.c ft_execut_cmd/ft_env.c    ft_execut_cmd/ft_unset.c ft_execut_cmd/ft_echo.c \

OBJ = ${SRC:.c=.o}

CFLAGS = -Wall -Wextra -Werror
RFLAGS = -lreadline -lncurses

CC = cc


NAME = minishell

LIBFT = ./includes/libft/libft.a
FLDLIBFT= ./includes/libft

#include readLine in MacOS
INRL = -lreadline -L/goinfre/bouhammo/homebrew/opt/readline/lib
LNRL= -lreadline -L/goinfre/bouhammo/homebrew/opt/readline/include

# include readLine in Linux
# INRL = -lreadline -L/usr/include/readline
# LNRL= -lreadline -L/usr/include/readline



all : ${LIBFT} ${NAME}

%.o: %.c minishell.h 
	${CC} ${CFLAGS} -c  $< -o $@

${NAME} : minishell.h ${OBJ}
		${CC} ${FLAGS}   ${SRC} ${LIBFT} ${INRL} ${LNRL} -o ${NAME}

${LIBFT}:
	make -C ${FLDLIBFT}
	make bonus -C ${FLDLIBFT}

clean:
	make fclean -C ./includes/libft
	@rm -rf ${OBJ}
	@echo "\033[34mminishell is clean from object files\033[0m"

fclean: clean
	@rm -rf ${NAME}
	@echo "\033[34mminishell is clean from program file\033[0m"

re : fclean all

.PHONY: all clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_direction.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/07 07:24:52 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/09 13:22:17 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_set_doc(t_command **new_node)
{
	(*new_node)->doc->dir_in = 0;
	(*new_node)->doc->dir_out = 0;
	(*new_node)->doc->rdir = 0;
	(*new_node)->doc->doc_here = 0;
	(*new_node)->doc->store = NULL;
}

void	ft_check_doc(t_command **new_node, t_splitor *tmp_x)
{
	t_splitor	*tmp;

	// int			i;
	tmp = tmp_x;
	// i = 0;
	(*new_node)->doc = malloc(sizeof(t_redirect));
	ft_set_doc(new_node);
	while (tmp != NULL)
	{
		if (tmp->type != '|' && ft_condition(tmp) && tmp->state == G)
		{
			if (tmp->type == '<')
				(*new_node)->doc->dir_in = 1;
			else if (tmp->type == '>')
				(*new_node)->doc->dir_out = 1;
			else if (tmp->type == HERE_DOC)
				(*new_node)->doc->doc_here = 1;
			else if (tmp->type == DREDIR_OUT)
				(*new_node)->doc->rdir = 1;
			(*new_node)->doc->len++;
		}
		tmp = tmp->next;
	}
	(*new_node)->doc->store = malloc(sizeof(char *) * (*new_node)->doc->len);
	tmp = tmp_x;
	// i = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_free.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/29 16:05:17 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/09 13:21:17 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_free_lexer(t_splitor **x)
{
	t_splitor	*tmp;

	while (*x != NULL)
	{
		tmp = *x;
		*x = (*x)->next;
		free(tmp->in);
		free(tmp);
	}
}

void	ft_free_env(t_envarment **my_env)
{
	t_envarment	*tmp;

	while (*my_env != NULL)
	{
		tmp = *my_env;
		*my_env = (*my_env)->next;
		free(tmp);
	}
}

void	ft_free_command(t_command *lst)
{
	t_command	*tmp;
	int			i;

	while (lst != NULL)
	{
		tmp = lst;
		lst = lst->next;
		i = 0;
		while (tmp->arg[i] != NULL)
		{
			free(tmp->arg[i]);
			i++;
		}
		free(tmp->arg);
		if (tmp->doc != NULL)
		{
			free(tmp->doc);
		}
		free(tmp);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_handle_synx.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/29 07:47:51 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/09 11:51:06 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_condition(t_splitor *start)
{
	if ((start->type != ' ' && start->type != -1 && start->type != '$'
			&& start->type != '\'' && start->type != '\"'))
		return (1);
	return (0);
}

int	ft_check_between(t_splitor **start)
{
	while ((*start) != NULL)
	{
		if ((*start)->type == '|' || (ft_condition(*start)
				&& ((*start)->state == G)))
		{
			if ((*start) != NULL)
				(*start) = (*start)->next;
			ft_skeep_space(&(*start));
			if ((*start) == NULL || (ft_condition(*start)))
				return (1);
		}
		else if (ft_condition(*start) && (*start)->state != G)
			while (((*start) != NULL) && (ft_condition(*start)
					&& (*start)->state != G))
				(*start) = (*start)->next;
		else if (!ft_condition(*start) && (*start)->state != G)
			while (((*start) != NULL) && !ft_condition(*start)
				&& (*start)->state != G)
				(*start) = (*start)->next;
		else if (((*start) != NULL) && (*start)->state == G)
			(*start) = (*start)->next;
	}
	return (0);
}

int	ft_handler_syn_error(t_splitor **x)
{
	t_splitor	*start;
	t_splitor	*end;

	if (!(*x))
		return (0);
	start = *x;
	if (start->type == '|' || ((start->type != ' ' && start->type != -1
				&& start->type != '$') && start->next == NULL)
		|| ((start->type == '\'' || start->type == '\"')
				&& start->next == NULL))
		return (1);
	if (ft_check_between(&start))
		return (1);
	start = *x;
	end = ft_lstlast(start);
	if (end->type == '|')
		return (1);
	return (0);
}

void	check_syn(t_splitor **x)
{
	if (ft_handler_syn_error(x))
	{
		ft_putstr_fd("Syntax Error:\n", 2);
		// exit(1);
	} // if (ft_check_expand(x))
		// 	printf("and I'm here");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_nodes_env.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/29 08:13:33 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/08 14:33:26 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_check_env(t_splitor **x, t_envarment *my_env)
{
	t_splitor	*tmp_cmd;
	t_envarment	*tmp_env;

	tmp_cmd = *x;
	tmp_env = my_env;
	while (tmp_cmd != NULL)
	{
		tmp_env = my_env;
		if (tmp_cmd->type == '$' && tmp_cmd->state != S)
		{
			while (tmp_env != NULL)
			{
				if (ft_strcmp(tmp_env->var, tmp_cmd->in + 1) == 0)
				{
					free(tmp_cmd->in);
					tmp_cmd->in = ft_strdup(tmp_env->data);
					break ;
				}
				tmp_env = tmp_env->next;
			}
		}
		tmp_cmd = tmp_cmd->next;
	}
}

t_envarment	*new_node(void *var, void *data)
{
	t_envarment	*elem;

	elem = (t_envarment *)malloc(sizeof(t_envarment));
	if (!elem)
		return (NULL);
	elem->var = var;
	elem->data = data;
	elem->next = NULL;
	return (elem);
}

void	add_back_node(t_envarment **lst, t_envarment *new)
{
	t_envarment	*p;

	p = *lst;
	if (!lst || !new)
		return ;
	if (!(*lst))
	{
		*lst = new;
		return ;
	}
	while (p->next)
	{
		p = p->next;
	}
	p->next = new;
}

t_envarment	*ft_stock_envarment(char **env)
{
	t_envarment	*var;
	char		**list;
	int			i;
	t_envarment	*elem;

	var = NULL;
	i = 0;
	while (env[i])
	{
		list = ft_split(env[i], '=');
		elem = new_node(list[0], list[1]);
		add_back_node(&var, elem);
		free(list);
		i++;
	}
	return (var);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_parsser.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/06 18:00:47 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/12 11:04:11 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_add_command(t_command **lst, t_command *new)
{
	t_command	*last;

	if (!lst || !new)
		return ;
	if (*lst == NULL)
		*lst = new;
	else
	{
		last = ft_last_command(*lst);
		last->next = new;
	}
}

t_command	*ft_last_command(t_command *lst)
{
	t_command	*last;

	last = lst;
	if (!lst)
		return (NULL);
	while (last->next != NULL)
		last = last->next;
	return (last);
}

void	ft_count_d_s(t_splitor **tmp, int *count)
{
	while ((*tmp) != NULL && ((*tmp)->state == D || (*tmp)->state == S))
		(*tmp) = (*tmp)->next;
	(*count)++;
}

void	ft_count_parameters(t_splitor *tmp_x, int *count)
{
	t_splitor	*tmp;

	tmp = tmp_x;
	if (tmp != NULL && tmp->type == '|')
		(*count)++;
	else if (tmp != NULL && tmp->type != '|')
	{
		while (tmp != NULL && tmp->type != '|')
		{
			ft_skeep_space(&tmp);
			if (tmp != NULL && tmp->state == G && tmp->type != '\"'
				&& tmp->type != '\'' && tmp->type != '|')
			{
				(*count)++;
				tmp = tmp->next;
			}
			else if (tmp != NULL && (tmp->state == D || tmp->state == S)
				&& tmp->type != '|')
				ft_count_d_s(&tmp, count);
			else if (tmp != NULL && tmp->type != '|')
				tmp = tmp->next;
		}
	}
}

void	ft_command(t_splitor **x, t_envarment **my_env, t_command **cmd)
{
	int			count;
	t_splitor	*tmp_x;
	t_command	*tmp_cmd;
	int			i;

	i = 0;
	(void)my_env;
	tmp_x = *x;
	while (tmp_x != NULL)
	{
		count = 0;
		ft_count_parameters(tmp_x, &count);
		printf("Count: %d\n", count);
		ft_add_command(cmd, ft_new_command(count, &tmp_x));
	}
	tmp_cmd = *cmd;
	i = 0;
	while (tmp_cmd != NULL)
	{
		printf("cmd ------------------<><><><>---------------------- \n");
		printf("content: %s \n", tmp_cmd->content);
		if (tmp_cmd->arg[i] != NULL)
			printf("argument: ");
		while (tmp_cmd->arg[i] != NULL)
		{
			printf(" %s ", tmp_cmd->arg[i]);
			i++;
		}
		printf("\n");
		printf("doc:\n");
		printf("dir_in: %d\n", tmp_cmd->doc->dir_in);
		printf("dir_out: %d\n", tmp_cmd->doc->dir_out);
		printf("rdir: %d\n", tmp_cmd->doc->rdir);
		printf("doc_here: %d\n", tmp_cmd->doc->doc_here);
		i = 0;
		printf("///////////////////////////////////////////////////////////n\n");
		// while (tmp_cmd->doc->store[i] != NULL)
		// {
		// 	printf("store: %s\n", tmp_cmd->doc->store[i]);
		// 	i++;
		// }
		
		tmp_cmd = tmp_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/25 15:25:28 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/07 19:28:22 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_state	ft_get_state(t_idx *var, char str_input)
{
	if (var->in_d == -1 && str_input == '\"' && var->in_s == -1)
		return (var->in_d = 1, G);
	else if (var->in_d == 1 && str_input == '\"' && var->in_s == -1)
		return (var->in_d = -1, G);
	else if (var->in_d == 1 && ft_isprint(str_input) && var->in_s == -1)
		return (D);
	else if (var->in_d == -1 && ft_isprint(str_input) && var->in_s == -1
		&& str_input != '\'')
		return (G);
	else if (var->in_s == -1 && str_input == '\'' && var->in_d == -1)
		return (var->in_s = 1, G);
	else if (var->in_s == 1 && str_input == '\'' && var->in_d == -1)
		return (var->in_s = -1, G);
	else if (var->in_s == 1 && ft_isprint(str_input) && var->in_d == -1)
		return (S);
	else if (var->in_s == -1 && ft_isprint(str_input) && var->in_d == -1
		&& str_input != '\"')
		return (G);
	return (3);
}

void	ft_get_word(char *str_input, t_idx *var, t_splitor **x)
{
	while (str_input[var->i] && !ft_check_input(str_input[var->i]))
	{
		var->state = ft_get_state(var, str_input[var->i]);
		var->i++;
		var->len++;
	}
	ft_add(x, ft_lstnew(ft_substr(str_input, var->start, var->len), var->len,
			WORD, var->state));
}

void	ft_her_dir(t_splitor **x, t_idx *var, char *str_input)
{
	var->len++;
	var->i++;
	if (var->len >= 1 && str_input[var->i] == '<')
		ft_add(x, ft_lstnew(ft_substr(str_input, var->start, var->len),
				var->len, HERE_DOC, ft_get_state(var, str_input[var->i])));
	else if (var->len >= 1 && str_input[var->i] == '>')
		ft_add(x, ft_lstnew(ft_substr(str_input, var->start, var->len),
				var->len, DREDIR_OUT, ft_get_state(var, str_input[var->i])));
}

void	ft_get_char(char *str_input, t_idx *var, t_splitor **x)
{
	var->len++;
	if (str_input[var->i] == '$' && !ft_check_input(str_input[var->i + 1]))
	{
		while (str_input[var->i] && !ft_check_input(str_input[var->i + 1]))
		{
			var->state = ft_get_state(var, str_input[var->i]);
			var->i++;
			var->len++;
		}
		ft_add(x, ft_lstnew(ft_substr(str_input, var->start, var->len),
				var->len, ENV, var->state));
	}
	else
	{
		if ((str_input[var->i] == '>' && str_input[var->i + 1] == '>')
			|| (str_input[var->i] == '<' && str_input[var->i + 1] == '<'))
			ft_her_dir(x, var, str_input);
		else
			ft_add(x, ft_lstnew(ft_substr(str_input, var->start, var->len),
					var->len, ft_get_token(str_input[var->i]), ft_get_state(var,
						str_input[var->i])));
	}
	var->i++;
}

void	ft_lexer(char *str_input, t_splitor **x)
{
	t_idx	var;

	var.i = 0;
	var.in_d = -1;
	var.in_s = -1;
	while (str_input[var.i])
	{
		var.start = var.i;
		var.len = 0;
		if (str_input[var.i] && !ft_check_input(str_input[var.i]))
			ft_get_word(str_input, &var, x);
		else if (str_input[var.i] && ft_check_input(str_input[var.i]))
			ft_get_char(str_input, &var, x);
	}
	if (var.in_d == 1 || var.in_s == 1)
		ft_putstr_fd("Syntax Error:\n", 2);
	check_syn(x);
	print_t_command(*x);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/25 13:23:44 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/07 07:53:11 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_t_command(t_splitor *cmd)
{
	if (cmd == NULL)
	{
		printf("Command is NULL\n");
		return ;
	}
	while (cmd != NULL)
	{
		printf("str_input: %s | ", cmd->in);
		printf("len: %d			| ", cmd->len);
		printf("token: %d		| ", cmd->type);
		if (cmd->state == 2)
			printf("state: GENERAL 		|\n");
		if (cmd->state == 1)
			printf("state: IN_SINGLE	|\n");
		if (cmd->state == 0)
			printf("state: IN_DOUBLE	|\n");
		cmd = cmd->next;
		printf("--------------------\n");
	}
}

int	ft_search(char *s, char *d)
{
	int	i;
	int	j;
	int	len;

	i = 0;
	j = 0;
	len = ft_strlen(s);
	while (s[i] && s[i])
	{
		if (s[i] == d[j])
			j++;
		if (len == j && s[i + 1] == d[j])
			return (1);
		i++;
	}
	return (0);
}

int	ft_isspace(char c)
{
	return ((c == ' ' || c == '\t' || c == '\n'));
}

t_token	ft_get_token(char str_input)
{
	if (str_input == ' ')
		return (WHITE_SPACE);
	else if (str_input == '\n')
		return (NEW_LINE);
	else if (str_input == '\'')
		return (QOUTE);
	else if (str_input == '\"')
		return (DOUBLE_QUOTE);
	else if (str_input == '$')
		return (ENV);
	else if (str_input == '|')
		return (PIPE_LINE);
	else if (str_input == '<')
		return (REDIR_IN);
	else if (str_input == '>')
		return (REDIR_OUT);
	return (0);
}

int	ft_check_input(char str_input)
{
	if (str_input == '|' || str_input == '<' || str_input == '>'
		|| str_input == '$' || str_input == '\'' || str_input == '\"'
		|| ft_isspace(str_input))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/17 13:08:06 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/12 14:39:16 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ff(void)
{
	system("leaks minishell");
}

// void	print_env(t_envarment **my_env)
// {
// 	t_envarment	*current_node;

// 	current_node = *my_env;
// 	while (current_node != NULL)
// 	{
// 		printf("%s\n", current_node->line);
// 		current_node = current_node->next;
// 	}
// }

void	ft_join_quote(t_splitor **tmp_x, char *s)
{
	while ((*tmp_x) != NULL && ((*tmp_x)->state == D || (*tmp_x)->state == S))
	{
		ft_strjoin(s, (*tmp_x)->in);
		(*tmp_x) = (*tmp_x)->next;
	}
	free(s);
}
void	print_envarment(t_envarment *env)
{
	t_envarment	*current;

	current = env;
	while (current != NULL)
	{
		printf("%s=%s\n", (char *)current->var, (char *)current->data);
		current = current->next;
	}
}

// ------------------------------
int	main(int ac, char **av, char **env)
{
	char		*str_input;
	t_splitor	*x;
	t_envarment	*my_env;
	t_command	*cmd;

	(void)ac;
	(void)av;
	x = NULL;
	my_env = NULL;
	my_env = ft_stock_envarment(env);
	// print_envarment(my_env);
	using_history();
	(void)cmd;
	while (1)
	{
		cmd = NULL;
		str_input = readline("\033[36m➨ minishell $:\033[0m  ");
		if (!str_input)
			exit(1);
		if (ft_strlen(str_input) > 0)
			add_history(str_input);
		ft_lexer(str_input, &x);
		ft_check_env(&x, my_env);
		ft_command(&x, &my_env, &cmd);
		ft_exute(my_env, cmd, env);
		ft_free_lexer(&x);
		ft_free_command(cmd);
		x = NULL;
		if (ft_search(str_input, "exit"))
			exit(0);
		free(str_input);
	}
	ft_free_env(&my_env);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/25 14:49:25 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/12 14:40:12 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# define _GNU_SOURCE

// call all the libriries we need in the project
# include "./includes/libft/libft.h"
# include "structures.h"
# include <curses.h>
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/ioctl.h>
# include <sys/stat.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <termios.h>
# include <unistd.h>

// function we use
int			ft_search(char *s, char *d);
int			ft_isspace(char c);
void		print_str_input(void *str_input);
void		print_t_command(t_splitor *cmd);
t_token		ft_get_token(char str_input);
int			ft_check_input(char str_input);
t_state		ft_get_state(t_idx *var, char str_input);
int			ft_condition(t_splitor *start);
int			ft_handler_syn_error(t_splitor **x);
void		ft_lexer(char *input, t_splitor **x);

t_envarment	*new_node(void *var, void *data);

void		add_back_node(t_envarment **lst, t_envarment *new);

t_envarment	*ft_stock_envarment(char **env);
int			ft_search_env(char *s, char *d);
void		ft_check_env(t_splitor **x, t_envarment *my_env);

void		check_syn(t_splitor **x);
void		ft_free_env(t_envarment **x);
void		ft_free_lexer(t_splitor **x);
void		ft_free_command(t_command *lst);
void		ft_add_command(t_command **lst, t_command *new);

void		ft_skeep_space(t_splitor **tmp_x);

int			ft_check_command(t_splitor *tmp_x);

t_command	*ft_new_command(int count, t_splitor **tmp_x);
t_command	*ft_last_command(t_command *lst);
void		ft_command(t_splitor **x, t_envarment **my_env, t_command **cmd);
void		print_env(t_envarment **my_env);
void		ft_check_doc(t_command **new_node, t_splitor *tmp);

//////////////////////  Execution  ////////////////////////

void  		ft_exute(t_envarment *var, t_command *list , char **env);
int 		ft_strcmp(char *s1, char *s2);
char 		**create_argv(t_splitor *elem) ;
char 		*path_command(char *ptr);
t_envarment *ft_stock_envarment(char **env);
int 		test_exist(t_envarment *var , char **list);

void 		free_args(char **args);// ft_export 
char		**split_line(char *ptr);// ft_export
char		**split_var(char *ptr);// ft_env
void 		print_export(t_envarment *var, t_command *str);
void  		execution_cmd(t_command 	*list , char **env);



// ///////            Commands         ///////
void 		ft_cd(t_command *list);
void 		ft_pwd(t_command *va_list);
void 		ft_export( t_envarment *var , t_command *str);
void 		ft_env( t_envarment *var);
void 		ft_unset(t_envarment *var , t_command *list);
void		ft_echo(t_command *list);
void		ft_echo_flag(t_command *list);


#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsser_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rel-mora <reduno96@gmail.com>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/06 18:00:12 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/07 22:35:30 by rel-mora         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_skeep_space(t_splitor **tmp_x)
{
	while ((*tmp_x) != NULL && (*tmp_x)->type == ' ')
		(*tmp_x) = (*tmp_x)->next;
}

int	ft_check_command(t_splitor *tmp_x)
{
	if (tmp_x != NULL && tmp_x->state == G && tmp_x->type != '\"'
		&& tmp_x->type != '\'' && tmp_x->type != '|')
		return (1);
	else if (tmp_x != NULL && (tmp_x->state == D || tmp_x->state == S)
		&& tmp_x->type != '|')
		return (1);
	else if (tmp_x != NULL && (tmp_x->state == D || tmp_x->state == S))
		return (1);
	return (0);
}

// void	ft_fill_path(t_command **new_node, t_splitor *tmp_x)
// {
// 	// char	*temp;
// 	while (tmp_x != NULL && tmp_x->state == G)
// 	{
// 		if ((tmp_x->next != NULL && tmp_x->state == G)
// 			&& (tmp_x->next->type == '>' || tmp_x->type == DREDIR_OUT))
// 		{
// 		}
// 		tmp_x = tmp_x->next;
// 	}
// }
void	ft_neuter_cmd(t_command **new_node, int *i, t_splitor **tmp_x)
{
	if ((*tmp_x) != NULL && (*tmp_x)->state == G && (*tmp_x)->type != '\"'
		&& (*tmp_x)->type != '\'' && (*tmp_x)->type != '|')
	{
		(*new_node)->arg[*i] = ft_strdup((*tmp_x)->in);
		(*i)++;
		(*new_node)->arg[*i] = NULL;
		(*new_node)->next = NULL;
		(*tmp_x) = (*tmp_x)->next;
	}
	else if ((*tmp_x) != NULL && ((*tmp_x)->state == D || (*tmp_x)->state == S)
		&& (*tmp_x)->type != '|')
	{
		(*new_node)->arg[*i] = ft_strdup("");
		while (tmp_x != NULL && ((*tmp_x)->state == D || (*tmp_x)->state == S))
		{
			(*new_node)->arg[*i] = ft_strjoin((*new_node)->arg[*i],
					(*tmp_x)->in);
			(*tmp_x) = (*tmp_x)->next;
		}
		(*i)++;
		(*new_node)->arg[*i] = NULL;
		(*new_node)->next = NULL;
	}
	else if (((*tmp_x) != NULL && (*tmp_x)->state == G)
		&& ((*tmp_x)->type == '\"' || (*tmp_x)->type == '\''))
	{
		(*tmp_x) = (*tmp_x)->next;
		if (((*tmp_x) != NULL && (*tmp_x)->state == G)
			&& ((*tmp_x)->type == '\"' || (*tmp_x)->type == '\''))
		{
			(*new_node)->arg[*i] = ft_strdup("");
			(*i)++;
			(*new_node)->arg[*i] = NULL;
			(*new_node)->next = NULL;
		}
	}
	else if ((*tmp_x) != NULL)
		(*tmp_x) = (*tmp_x)->next;
}

void	ft_not_pipe(t_command **new_node, int *i, t_splitor **tmp_x)
{
	while ((*tmp_x) != NULL && (*tmp_x)->type != '|')
	{
		if ((*tmp_x) != NULL && (*tmp_x)->type != ' ')
			ft_neuter_cmd(new_node, i, tmp_x);
		ft_skeep_space(tmp_x);
	}
}

t_command	*ft_new_command(int count, t_splitor **tmp_x)
{
	t_command	*new_node;
	t_splitor	*tmp;
	int			i;

	tmp = *tmp_x;
	i = 0;
	new_node = malloc(sizeof(t_command));
	new_node->arg = malloc(sizeof(char *) * (count + 1));
	if (((*tmp_x) != NULL && (*tmp_x)->type == '|'))
	{
		new_node->arg[i] = ft_strdup((*tmp_x)->in);
		i++;
		new_node->arg[i] = NULL;
		new_node->next = NULL;
		(*tmp_x) = (*tmp_x)->next;
	}
	else if ((*tmp_x) != NULL && (*tmp_x)->type != '|')
		ft_not_pipe(&new_node, &i, tmp_x);
	new_node->content = new_node->arg[0];
	new_node->doc = NULL;
	ft_check_doc(&new_node, tmp);
	return (new_node);
}
#!/bin/bash
# Simple script to greet the user
42 -c

42 -brew

42 -c

brew install readline


brew link readline --force

brew --prefix readline


export LDFLAGS="-L/goinfre/rel-mora/homebrew/opt/readline/lib"
export CPPFLAGS="-I/goinfre/rel-mora/homebrew/opt/readline/include"



source ~/.zshrc

#gcc -Wall -Wextra -Werror main.c -lreadline -L/goinfre/rel-mora/homebrew/opt/readline/lib -I/goinfre/rel-mora/homebrew/opt/readline/include/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   structures.h                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bouhammo <bouhammo@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/07 07:58:38 by rel-mora          #+#    #+#             */
/*   Updated: 2024/08/11 10:27:50 by bouhammo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef STRUCTURES_H
# define STRUCTURES_H

typedef struct s_idx
{
	int					i;
	int					j;
	int					len;
	int					start;
	int					state;
	int					in_s;
	int					in_d;
}						t_idx;

typedef enum e_token
{
	WORD = -1,
	WHITE_SPACE = ' ',
	NEW_LINE = '\n',
	QOUTE = '\'',
	DOUBLE_QUOTE = '\"',
	ENV = '$',
	PIPE_LINE = '|',
	REDIR_IN = '<',
	REDIR_OUT = '>',
	HERE_DOC,
	DREDIR_OUT,
}						t_token;

typedef struct s_path_file
{
	char				**path;
	struct s_path_file	*next;
}						t_path_file;

typedef struct s_redirect
{
	int					len;
	int					dir_in;
	int					dir_out;
	int					rdir;
	int					doc_here;
	char				**store;
}						t_redirect;

typedef enum e_state
{
	D,
	S,
	G,
	NUL,
}						t_state;
typedef struct s_splitor
{
	char				*in;
	int					len;
	enum e_token		type;
	enum e_state		state;
	struct s_splitor	*next;
}						t_splitor;

typedef struct s_envarment
{
	char				*var;
	char				*data;
	struct s_envarment	*next;
}						t_envarment;

typedef struct s_command
{
	char				*content;
	char				**arg;
	t_redirect			*doc;
	struct s_command	*next;
}						t_command;

#endif